{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Backend Development Utilities","text":"<p>Backend Development Utilities is a library to provide python backend developers a bunch of useful shortcuts and wrappers.</p> <p> </p> pip install backend-dev-utils"},{"location":"change_log/","title":"Change Log","text":""},{"location":"change_log/#v100","title":"v1.0.0","text":"<ul> <li>New structure of FastAPI Helpers depending on feedbacks and suggestions</li> <li>URL methods now return the url instance (self)</li> <li>Tests are updating according to the changes</li> <li>DB Handlers module tests are improved and achieved 100% coverage</li> </ul>"},{"location":"database_handlers/","title":"Database Handlers","text":"<p>Database Handlers are Singleton  or NamedSingleton  classes to handle database connections, engines and sessions using SQLModel.</p>"},{"location":"database_handlers/#singledatabasehandler","title":"SingleDatabaseHandler","text":"<p>SingleDatabaseHandler is a singleton to create a db instance. Once you create an instance of the db, it will be the only db that you can create. Even if you call the class again with different arguments - or no arguments, it will return you the first db instance. The parameter echo is the one from SQLModel, and if create_tables is True, all the tables will be created by SQLModel automatically during the initialization of the db instance. </p> <pre><code>from backend_dev_utils import SingleDatabaseHandler\n\ndb = SingleDatabaseHandler(\n    database_uri=\"sqlite:///:memory:\", echo=True, create_tables=True\n)\n\nsession = db.get_session()\n\n\ndb2 = SingleDatabaseHandler()\n</code></pre>"},{"location":"database_handlers/#multipledatabasehandler","title":"MultipleDatabaseHandler","text":"<p>MultipleDatabaseHandler is almost the same with SingleDatabaseHandler, but it can handle multiple db instance with different names. It is a NamedSingleton (please see the NamedSingleton in DesignPatterns module).</p> <pre><code>from backend_dev_utils import MultipleDatabaseHandler\n\nfirst_db = MultipleDatabaseHandler(\n    name=\"first_db\", database_uri=\"sqlite:///:memory:\", echo=True, create_tables=True\n)\n\nsession = first_db.get_session()\n</code></pre>"},{"location":"design_patterns/","title":"Design Patterns","text":"<p>This module contains base classes or wrappers for creating Python design patterns easily.</p>"},{"location":"design_patterns/#singleton","title":"Singleton","text":"<p>Create a class inheriting from SingletonBase, and that's it.</p> <pre><code>from backend_dev_utils import SingletonBase\n\n\nclass MyClass(SingletonBase):\n    def __init__(self, value):\n        self.value = value\n\n\nobj1 = MyClass(10)\nobj2 = MyClass(20)\n\nprint(obj1.value)  # Output: 10\nprint(obj2.value)  # Output: 10\nprint(obj1 is obj2)  # Output: True\n</code></pre>"},{"location":"design_patterns/#namedsingleton","title":"NamedSingleton","text":"<p>Create a class inheriting from NamedSingletonBase and its first argument should always be name, which is a string. Then when you call this class with name instance1 let's say, and if you have never called it with the name instance1, then the instance will be created. Otherwise, you will get the instance created when you called the class with that name before. </p> <pre><code>from backend_dev_utils import NamedSingletonBase\n\n\nclass TestClass(NamedSingletonBase):\n    def __init__(self, name: str, value: int) -&gt; None:\n        self.name = name\n        self.value = value\n\n\nobj1 = TestClass(\"instance1\", 10)\nobj2 = TestClass(\"instance1\", 20)\nobj3 = TestClass(\"instance2\", 30)\n\nprint(obj1.name, obj1.value)  # Output: instance1 10\nprint(obj2.name, obj2.value)  # Output: instance1 10\nprint(obj3.name, obj3.value)  # Output: instance2 30\nprint(obj1 is obj2)  # Output: True\nprint(obj1 is obj3)  # Output: False\n</code></pre>"},{"location":"fastapi_helpers/","title":"FastAPI Helpers","text":"<p>FastAPI Helpers module contains wrapper classes for FastAPI routes, routers and apps. </p> <pre><code>from backend_dev_utils import FastAPIApp\n\n\napp = FastAPIApp(title=\"My FastAPI App\", version=\"1.0.0\")\n</code></pre> <p>Assuming that you put this code snippet in main.py, you can run it by:</p> fastapi run main.py <p>And this is what you will get at \"http://localhost:8000/docs\":</p> <p></p> <p>This was a basic application that contains only the default route that I include in the app. But if you don't want to include it, and create your own routers and routes:</p> <pre><code>from backend_dev_utils import FastAPIApp, FastAPIRouter, FastAPIRoute\n\n\ndef hello_endpoint(name: str):\n    return {\"message\": f\"Hello {name}\"}\n\n\nhello_route = FastAPIRoute(path=\"/hello\", endpoint=hello_endpoint, methods=[\"GET\"])\n\nmy_router = FastAPIRouter(prefix=\"/api/v1\", tags=[\"my-router\"])\nmy_router.add_route(hello_route)\n\nfastapi_app = FastAPIApp(\n    routers=[my_router],\n    title=\"Hello API\",\n    description=\"An API to say hello.\",\n    version=\"0.0.1\",\n    include_default_router=False,\n)\n\napp = fastapi_app.app\n</code></pre> <p>And when you run it, you will get:</p> <p></p> <p>Or you can add the FastAPIRoute object directly to the FastAPI app as:</p> <pre><code>from backend_dev_utils import FastAPIApp, FastAPIRouter, FastAPIRoute\n\n\ndef hello_endpoint(name: str):\n    return {\"message\": f\"Hello {name}\"}\n\n\nhello_route = FastAPIRoute(path=\"/hello\", endpoint=hello_endpoint, methods=[\"GET\"])\n\nfastapi_app = FastAPIApp(\n    routes=[hello_route],\n    title=\"Hello API\",\n    description=\"An API to say hello.\",\n    version=\"0.0.1\",\n    include_default_router=False,\n)\n\napp = fastapi_app.app\n</code></pre>"},{"location":"http_helpers/","title":"HTTP Helpers","text":"<p>HTTP Helpers module contains helper functions for making http, requests, url validations etc. Its name contains \"HTTP\" but it might contain helper functions for other protocols. I named it like this because http seems cool in a module name .</p>"},{"location":"http_helpers/#url","title":"URL","text":"<p>First, the class validates the URL at intialization.</p> from backend_dev_utils import URLurl = URL(\"http://////example.com\")backend_dev_utils.http_helpers.exceptions.InvalidURLError: Invalid URL: http://////example.com <p>Then you can change its scheme, netloc, path, params and fragment:</p> from backend_dev_utils import URLurl = URL(\"http://www.example.com\")url.with_scheme(\"https\")https://www.example.comurl.with_netloc(\"example2.net\")https://example2.neturl.with_path(\"/hello/world\")https://example2.net/hello/worldurl.with_query_param(key=\"hello\", value=\"world\")https://example2.net/hello/world?hello=worldurl.delete_query_param(\"hello\")https://example2.net/hello/worldurl.with_fragment(\"hello\")https://example2.net/hello/world#hello"},{"location":"logger_manager/","title":"Logger Manager","text":"<p>LoggerManager is a NamedSingleton to provide logger instances with provided configuration. In this module we have the get_logger function to return a logger instance from this singleton. </p> <p>With only name argument provided, it will return a stream logger (which only logs to console) and the other arguments will take their default values as logging level info and stream logger format %(name)s - %(levelname)s - %(message)s.</p> from backend_dev_utils import get_loggerlogger = get_logger(name=\"my-logger\")logger.info(\"Hello World!\")my-logger - INFO - Hello World! <p>Or, if you provide the argument file_path, the logger will automatically create a logger that logs to file.</p> <pre><code>import logging\n\nfrom backend_dev_utils import get_logger\n\n\nlogger = get_logger(\n    name=\"my-logger\",\n    level=logging.INFO,\n    file_path=\"my-log-file.log\",\n    file_format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\nlogger.info(\"Hello World!\")\n</code></pre> <p>Finally, if you provide the rotating_file_path argument, the output file size will be limited by max_bytes argument, and at most backup_count of files will be created named as log-file.log.1, log-file.log.2 etc. And when all limits are full and it needs to write a new log file, it starts deleting from the oldest one.</p> <pre><code>import logging\n\nfrom backend_dev_utils import get_logger\n\n\nlogger = get_logger(\n    name=\"my-logger\",\n    level=logging.INFO,\n    rotating_file_name=\"my-rotating-log-file.log\",\n    file_format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    max_bytes=10000,\n    backup_count=5,\n)\n\nlogger.info(\"Hello World!\")\n</code></pre>"},{"location":"test/","title":"Test","text":"pip install backend-dev-utils Done! pythonimport requestsrequests.get('https://exampls.com')&lt;Response [200]&gt;&gt;&gt;&gt;"}]}